---
title: 算法设计与分析(13) 算法分析与问题的计算复杂度
categories: [blog, ada]
tags: [complexity]
date: 2019-04-03
author: lscpku
---

{% include MathJaxHead.html %}

# 算法分析与问题的计算复杂度

---

- 寻找最优算法<br>
算法$A$的最坏时间复杂度$W(n)$，最坏情况下复杂度下界$F(n)$，若$W(n)\neq \Theta(F(n))$，则改进算法或提高下界。

## 1. 平凡下界

- 平凡下界：输入和输出规模<br>
例：求两个$n \times n$矩阵的乘积，下界 $\Omega(n^2)$

## 2. 直接计数求解该问题所需的最少运算

例：基于比较找最大数：$n-1$

## 3. 决策树

- 二叉树的性质：$n$个结点的二叉树深度至少为$\lfloor\log n\rfloor$
- 若二叉树每个内结点都有2个儿子，则叶结点数量$t \leqslant 2^d$

## 4. 检索算法的时间复杂度分析

- 检索问题：给定递增数组$L$和数$x$，若$x$在$L$中返回其下标，否则返回0
- 顺序检索
``` cpp
j = 1
while j<=n and L(j)!=x do
    j = j + 1
if j > n then j = 0
```
- 二分检索<br>
最坏情况下复杂度 $W(n) = \lfloor \log n \rfloor +1$<br>
平均情况下复杂度 $A(n) = \lfloor \log n \rfloor +\frac12$<br>
- 检索问题的决策树<br>
设$A$是一个检索算法，其决策树是一棵二叉树，结点标记为$1,2,\ldots,n$
1. 首先与$x$比较的$L$的项的下标标记为树根
2. 假设某结点标记为$i$
    - $i$的左儿子：当$x<L(i)$时，算法$A$下一步与$x$比较的项的下标
    - $i$的右儿子：当$x>L(i)$时，算法$A$下一步与$x$比较的项的下标
    - 若$x<L(i)$时算法停止，则$i$无左儿子
    - 若$x>L(i)$时算法停止，则$i$无右儿子<br>
最坏情况下的基本运算次数是树的深度+1

> 对于任何一个检索算法，存在规模为$n$的输入使得该算法至少要做$\lfloor \log n \rfloor +1$次比较.

## 5. 排序算法的时间复杂度分析

- 冒泡排序<br>
考虑交换发生在相邻元素间的排序算法类<br>
每次交换最多减少1个逆序对<br>
最大逆序数 $n(n-1)/2$<br>
平均逆序数 $n(n-1)/4$<br>
最坏和平均复杂度均为$\Theta(n^2)$

- 堆排序

- 排序问题的决策树<br>
考虑基于比较的排序算法类<br>
任取算法$A$，$L=\{x_1,x_2,\ldots,x_n\}$，如下定义决策树：
1. 第一次比较元素为$x_i, x_j$，则树根标记为$i,j$
2. 假设结点$k$标记为$i,j$:
    - $x_i<x_j$<br>
    若算法结束，$k$的左儿子标记为输出<br>
    若下一步比较元素$x_p,x_q$，那么$k$的左儿子标记为$p,q$
    - $x_i>x_j$<br>
    若算法结束，$k$的右儿子标记为输出<br>
    若下一步比较元素$x_p,x_q$，那么$k$的右儿子标记为$p,q$

## 6. 选择算法的时间复杂度分析

## 7. 通过归约确认问题计算复杂度的下界